## 存储空间

- 堆：对象本身
- 栈：基本数据类型变量以及对象引用（局部变量）
- 方法区：类型信息，字段信息，常量池，静态变量，方法信息等。**该区域是线程共享区域**

注意：不管对象是通过怎样的方式创建的，其引用都会存储在栈中，而根据**对象类型不同、对象创建方式不同**，对象本身可能存储在常量池或者堆中

每当一个方法被调用，方法内的局部变量（不是对象以及对象句柄）都会被储存再方法栈（属于栈空间）中，当方法调用结束，就会把方法栈中的局部变量全部销毁


## 基本数据类型创建

基本数据类型没有引用，创建时只会生成一个变量，并且存于栈中。与c++中的变量定义一致。

但是基本数据类型在创建时，也会在栈中寻找是否有相同值的变量存在，如果存在的话，即在栈中分配一块内存用来存储相同的值

## 对象创建的方法

### 以Integer为例

1. 在堆中创建新的整型对象，在栈中存放新的对象引用
```java
Integer a = new Integer(1);
```

1. 如果在常量池中找到值为1的整型对象（-128~127以内都能找到），那么就只新建一个对象引用，引用指向常量池中的对象。如果在常量池中找不到，则新建对象(new)、对象引用
```java
Integer a = Integer.valueOf(1);
```

1. 与valueOf一致
```java
Integer a = 1;
```

注意整型的常量池是固定不变的（-128~127），不会因为新建了一个130的对象就将其加入常量池中，这一点与String不一样。

### 以String为例

1. 在堆中创建一个新的对象，在栈中存放新的对象引用。如果常量池中没有对应的字符串，则在常量池中也创建一个新的字符串对象。
```java
String a = new String("aaa");
```

2. 如果在常量池中找到相同值的对象，那么就只新建一个对象引用，引用指向常量池中的对象。如果在常量池中找不到，则新建两个对象（new方法，一个在常量池一个在堆）、对象引用
```java
String a = String.valueOf("aaa");
```
3. 与valueOf一致
```java
String a = "abc";
```

与整型类的区别在于new新建时会查找常量池中是否有对应对象，如果没有会在常量池中也新建一个对象，当然在堆中本来就会新建一个对象

### 总结

对于任何类对象，new方法首先会在堆中创建新的对象，在栈中创建新的对象引用。而对于String对象，new的时候还会查看常量池中有没有该对象，没有的话还会在常量池中创建一个新对象。

对于任何类对象，valueOf方法首先创建一个新的对象引用，然后查找常量池，如果有则直接引用指向常量池中的该对象；如果没找到，则会调用各自的new方法。

## 对象的作用域

java中不允许使用大括号来区分同一个对象的不同作用域
```java
{
  int x = 12;
  {
    int x = 96; /* illegal */
  }
}
```

而这样是可以的。
```java
{
    int x = 1;
    System.out.println(x); // 1
    {
        x ++;
        System.out.println(x);  // 2
    }
}
```

## 对象的生命周期

使用new创建的对象，在其作用域结束后，对象引用会自动消除，但是对象不会。java中有gc机制来释放这部分内存。

## Java程序

首先需要import对应类库

java程序的执行其实是类文件的执行

但是类只有创建了，才能执行。否则就算有类的定义，也无法执行任何内容。

那么就需要在定义这个类时，**声明一个static方法**，静态方法存于方法区，属于类的方法（不是对象的方法），可以脱离对象而直接执行。

所以就有了下面这种代码：

```java
// import java.util.*; 
public class App {
    public static void main(String[] args) throws Exception {
    }
}
```


