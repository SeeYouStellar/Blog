### 1. c++三个特性

1. 封装性：封装可以隐藏实现细节，使得代码模块化。封装是把过程和数据包围起来，对数据的访问只能通过已定义的成员函数。（与c不同点在于，c++

   struct类型的所有成员都是public权限，而c++引进了类，使得类内的成员可以有private权限，通常将想要隐藏的信息设为private权限）

2. 继承性：

3. 多态性：一个接口，多种方法。有两种多态：

   1. 编译时多态性（静态多态）：通过重载函数实现
   2. 运行时多态性（动态多态）：通过虚函数实现（基类指针指向子类对象时，调用基类和子类同名的函数时，调用的是子类的函数） 

### 2. 智能指针

### 3. 强转

1. static_cast<>:

   static_cast 用于进行比较“自然”和低风险的转换，如整型和浮点型、字符型之间的互相转换。另外，如果对象所属的类重载了强制类型转换运算符 T（如 T 是 int、int* 或其他类型名），则 static_cast 也能用来进行对象到 T 类型的转换。

   static_cast 不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。因为这些属于风险比较高的转换.

2. reinterpret_cast<>:

   reinterpret_cast 用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和**能容纳指针**的整数类型之间的转换。注意这里的容量，只有容量能完整存下指针的类型才行。比如int*（8Byte）可转为long(8Byte)，不能转为int(4Byte)

3. const_cast<>：

   const_cast 运算符仅用于进行去除 const 属性的转换，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。将 const 引用转换为同类型的非 const 引用，将 const 指针转换为同类型的非 const 指针时可以使用 const_cast 运算符。例如：

   ```c++
   const string s = "Inception";
   string& p = const_cast <string&> (s);
   string* ps = const_cast <string*> (&s);  // &s 的类型是 const string*
   ```

4. dynamic_cast<>:

   dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。

   ```c++
   #include <iostream>
   #include <string>
   using namespace std;
   class Base
   {  //有虚函数，因此是多态基类
   public:
       virtual ~Base() {}
   };
   class Derived : public Base { };
   int main()
   {
       Base b;
       Derived d;
       Derived* pd;
       pd = reinterpret_cast <Derived*> (&b);
       if (pd == NULL)
           //此处pd不会为 NULL。reinterpret_cast不检查安全性，总是进行转换
           cout << "unsafe reinterpret_cast" << endl; //不会执行
       pd = dynamic_cast <Derived*> (&b);
       if (pd == NULL)  //结果会是NULL，因为 &b 不指向派生类对象，此转换不安全
           cout << "unsafe dynamic_cast1" << endl;  //会执行
       pd = dynamic_cast <Derived*> (&d);  //安全的转换
       if (pd == NULL)  //此处 pd 不会为 NULL
           cout << "unsafe dynamic_cast2" << endl; //不会执行
       return 0;
   }
   ```


### 4. static使用场景

- 静态成员变量（面向对象）
- 静态成员函数（面向对象）
- 静态全局变量（面向过程）
- 静态局部变量（面向过程）
- 静态函数（面向过程）

参考博客https://zhuanlan.zhihu.com/p/37439983

### 5. const使用场景

- const+普通变量
- const+指针变量
- const+形参
- const+类成员函数

参考博客https://www.runoob.com/w3cnote/cpp-const-keyword.html

### 6. 指针与应用的区别

1. 指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。

2. 引用在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。（注：不能有引用的值不能为NULL）

3. 有多级指针，但是没有多级引用，只能有一级引用。

4. 指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值加1）

5. sizeof 引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是指针本身的大小。

6. 引用访问一个变量是直接访问，而指针访问一个变量是间接访问。

### 7. 临时变量

临时变量是const型变量。是在某些情况下编译器自动生成的，不是程序员声明的。

产生场景：

1. 强制类型转换，隐式类型转换
2. 赋值过程中，等号右边的是一个表达式，即int a=10+20
3. "abc", 100,这些就是临时变量
4. 在函数返回时, **返回值也会以临时变量的形式返回.**及返回值只能被当作右值。（但若返回值是引用，则可做左值）

函数形参传递实际上是一个赋值的过程：**形参=实参**

故在这个赋值过程中，有可能会有类型转换，也可能会有表达式传递，或者直接传“abc"等等，故就会产生临时变量。**注意**不是函数传参一定会产生临时变量，而是有可能。

### 8. 常量引用：可绑定常量（临时变量）

先来看一个例子

```c++
int& a = 10;     //1 报错
const int b = 10;
int& c = b;     //2 报错
const int& d = 10; //3正确
```

因为10是临时变量，也就是常量，又因为常量不能赋给非常量引用。所以前两个会报错。

**！！！为什么常量不能赋给非常量引用？**

> 因为c++认为，使用普通引用绑定一个对象，就是为了能通过引用对这个对象做改变。如果普通引用绑定的是一个临时量而不是对象本身，那么改变的是临时量而不是希望改变的那个对象，这种改变是无意义的。所以规定普通引用不能绑定到临时量上。
>
> 那么为什么常量引用就可以呢，因为常量是不能改变的。也就是说，不能通过常量引用去改变对象，那么绑定的是临时量还是对象都无所谓了，反正都不能做改变也就不存在改变无意义的情况。

### 9. 野指针和空指针

野指针是未初始化的指针，其空间内的地址值是之前留下来的，是未知的。

空指针是初始化过的指针，它不指向任何空间

```c++
int* a = NULL;
int* b;
cout<<b;  // 不会报错，但很危险，因为不知道它会指向哪
cout<<*a;  // 会报错，因为空指针不指向任何空间

```

### 10. 头文件中的ifndef/define/endif有什么作用？

答：这是C++预编译头文件保护符，保证即使文件被多次包含，头文件也只定义一次。

### 11. #include<file.h> 与 ＃include "file.h"的区别？

答：前者是从标准库路径寻找和引用file.h，而后者是从当前工作路径搜寻并引用file.h。

### 12. sizeof与strlen的区别？

答：

1. sizeof的返回值类型为size_t（unsigned int）；
2. sizeof是运算符，而strlen是函数；
3. sizeof可以用类型做参数，其参数可以是任意类型的或者是变量、函数，而strlen只能用char*做参数，且必须是以’\0’结尾；
4. 数组作sizeof的参数时不会退化为指针，而传递给strlen是就退化为指针；
5. sizeo是编译时的常量，而strlen要到运行时才会计算出来，且是字符串中字符的个数而不是内存大小；

### 13.数组与指针的区别

1. 分配空间的区别：数组一般在栈区或数据段或bss段，即要么是局部数组，要么是全局数组（或者静态数组）；而指针有可能是动态分配的，所以有可能在自由存储区。

2. 赋值的区别：

   ```c++
   char ar[] = "hello";
   cout<<ar<<endl;
   ar[1] = 'E';    // correct
   char *p = "hello";
   cout<<p<<endl;
   p[1] = 'E';     // Error
   ```

   数组的赋值是开辟空间存储“hello”，而指针赋值是将指针的值初始化为“hello”常量的地址，故若想改变常量的地址，肯定报错

3. sizeof运算符的区别：

   ```c++
   int* p = new int[10];
   int arr[10];
   cout<<sizeof(arr); // 10*8=80
   cout<<sizeof(p);   // 4;
   ```

### 14.new和malloc区别

1. new/delete是c++独有运算符，malloc/free是c标准库函数。对于类类型的对象而言，用malloc/free无法满足要求的。对象在创建的时候要自动执行构造函数，消亡之前要调用析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制之内，不能把执行构造函数和析构函数的任务强加给它，因此，C++还需要new/delete。
2. 其他区别：参考博客https://www.cnblogs.com/qg-whz/p/5140930.html

### 15.多态类中的虚函数表是 Compile-Time，还是 Run-Time时建立的?

虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组。而对象的隐藏成员--虚拟函数表指针是在运行期--也就是构造函数被调用时进行初始化的，这是实现多态的关键。

### 16. 完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？**

答案：这些函数的区别在于 实现功能以及操作对象不同。

（1）strcpy 函数操作的对象是字符串，完成从源字符串到目的字符串的拷贝功能。

（2）sprintf 函数操作的对象不限于字符串：虽然目的对象是字符串，但是源对象可以是字符串、也可以是任意基本类型的数据。这个函数主要用来实现（字符串或基本数据类型）向字符串的转换功能。如果源对象是字符串，并且指定 %s 格式符，也可实现字符串拷贝功能。

（3）memcpy
函数顾名思义就是内存拷贝，实现将一个内存块的内容复制到另一个内存块这一功能。内存块由其首地址以及长度确定。程序中出现的实体对象，不论是什么类型，其最终表现就是在内存中占据一席之地（一个内存区间或块）。因此，memcpy

的操作对象不局限于某一类数据类型，或者说可适用于任意数据类型，只要能给出对象的起始地址和内存长度信息、并且对象具有可操作性即可。鉴于memcpy
函数等长拷贝的特点以及数据类型代表的物理意义，memcpy
函数通常限于同种类型数据或对象之间的拷贝，其中当然也包括字符串拷贝以及基本数据类型的拷贝。

对于字符串拷贝来说，用上述三个函数都可以实现，但是其实现的效率和使用的方便程度不同：

• strcpy 无疑是最合适的选择：效率高且调用方便。

• sprintf 要额外指定格式符并且进行格式转化，麻烦且效率不高。

• memcpy 虽然高效，但是需要额外提供拷贝的内存长度这一参数，易错且使用不便；并且如果长度指定过大的话（最优长度是源字符串长度 +
1），还会带来性能的下降。其实 strcpy 函数一般是在内部调用 memcpy 函数或者用汇编直接实现的，以达到高效的目的。因此，使用
memcpy 和 strcpy 拷贝字符串在性能上应该没有什么大的差别。

对于非字符串类型的数据的复制来说，strcpy 和 snprintf 一般就无能为力了，可是对 memcpy
却没有什么影响。但是，对于基本数据类型来说，尽管可以用 memcpy
进行拷贝，由于有赋值运算符可以方便且高效地进行同种或兼容类型的数据之间的拷贝，所以这种情况下 memcpy 几乎不被使用 。memcpy
的长处是用来实现（通常是内部实现居多）对结构或者数组的拷贝，其目的是或者高效，或者使用方便，甚或两者兼有。

### 17. static全局变量与普通的全局变量有什么区别

static全局变量只初使化一次，防止在其他文件单元中被引用。

### 18. c++源代码到可执行文件的过程

c++源代码到可执行文件的过程：预编译(预处理)->编译->汇编->链接

| 阶段           | 作用                                                         | 执行命令                                                 | 生成文件后缀 |
| -------------- | ------------------------------------------------------------ | -------------------------------------------------------- | ------------ |
| 预编译         | 读取源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理 | `gcc -E hello.c -o hello.i`                              | .i           |
| 编译(编译原理) | 编译过程就是把预处理完的文件进行一系列的词法分析，语法分析，语义分析及优化后生成相应的汇编代码。 | `gcc –S hello.c –o hello.s`                              | .s           |
| 汇编           | 汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。 | `gcc –c hello.c –o hello.o`                              | .o           |
| 链接           | 将上几步执行结果与链接库（动态/静态）链接起来。              | `gcc hello.c -o –L /usr/lxy/lib –lmysqlclient hello.out` | .out         |

静态库：.h+.lib

动态库：.h+.dll

这里注意预编译和链接的区别：预处理时是把#ifdef,#ifndef,#define,#include后的代码块进行提前处理，#ifdef和#ifndef配合#define使用时可以防止重复引入。#include则会把头文件的内容合并到源文件中。而一般#include 的.h头文件可能是静态库也可能是动态库，实际上.h文件可以看成接口的定义，而接口的实现是不会合并到源代码中的，故需要以链接的形式来引用这些接口的实现。在实际执行gcc命令时还要告诉系统去哪找这些接口的实现文件（.lib文件/.dll文件）。使用的参数为-I, -L。

gcc/g++指令的一些参数：

```
–I /usr/include ：指定头文件所在的目录
-Lhello:或者-L libhello.so,一般和-I同时使用，表示某个目录下的某个库
```

### 19. 静态链接库(.lib/.a)和动态链接库(.dll/.so)

参考https://www.zhihu.com/question/20484931,https://www.cnblogs.com/cyyljw/p/10949660.html

静态链接：

 ![20180505235327609](20180505235327609) 

### 20. size_t类型

